1. A binary tree is a special tree structure where each of its nodes may have up to two child nodes, a left and a right node. The right side of the binary tree contains only nodes that are greater than their parent nodes and the left side contains only nodes that are less than the parent. 

2. A heuristic is a guess that an algorithm makes that helps to solve a complex problem quickly, but the solution will not always be the most accurate. Heuristics employ a practical method and are sufficient enough for meeting an immediate goal.

3. Another example of a heuristic is an educated guess. An educated guess allows a person to reach a solution without exhaustive research, based on what they have experienced and learned in the past.

4. Depth-first search is the process of traveling down a single branch at a time to find a node. Only until you reach the last node in the branch does it move upwards and repeats the process with the next branch, until the node is found.

With breadth-first search, an entire row of nodes is searched before moving onto the next row, until the desired node is found.

5. An undirected, a-cyclic, unweighted graph does not have a specific start or end point. Each node may connect to many other nodes, without forming a closed loop, or circle of nodes. This type of graph also does not factor in the travel times between nodes.

6. A binary search tree is a directed, a-cyclic, unweighted graph.

1.

FUNCTION findValue (root, value)
	IF the root node does not exist
		RETURN false
	ELSE 
		SET current to root
		WHILE current
			IF current.value equals value
				RETURN true
			ELSE IF value < current.value
				SET current to current.left
			ELSE IF value > current.value
				SET current to current.right
		END WHILE
		RETURN False
	END IF
END FUNCTION


function findValue(root, value) {
  if (root === null) {
    return false;
  } else {
    let current = root;
    while (current) {
      if (current.value === value) {
        return true;
      } else if (value < current.value) {
        let current = current.left;
      } else if (value > current.value) {
        let current = current.right;
      }
      return false;
    }
  }
}


2.

FUNCTION distanceBetweenNodes(n1, n2)
	IF n1 equals null
		RETURN false
	ELSE 
		SET current to n1
		WHILE current 
			IF current.value equals n2
				RETURN 0
			ELSE IF n2 is less than current.value
				RETURN 1 + distanceBetweenNodes(current.left, n2)
			ELSE IF n2 is greater than current.value
				RETURN 1 + distanceBetweenNodes(current.right, n2)
			END IF
		END WHILE
	END IF
END FUNCTION


function distanceBetweenNodes(n1, n2) {
  if (n1 === null) {
    return undefined;
  } else {
    let current = n1;
    while (current) {
      if ((current.value = n2)) {
        return 0;
      } else if (n2 < current.value) {
        return 1 + distanceBetweenNodes(current.left, n2);
      } else if (n2 > current.value) {
        return 1 + distanceBetweenNodes(current.right, n2);
      }
    }
  }
}



				
	

	
